## 默认的 DLL 搜索路径优先级.md
在默认情况下，Windows 加载程序在用户磁盘上搜索 DLL 的搜索顺序：

1. 包含可执行文件的目录。
2. Windows 的系统目录，该目录可以通过 GetSystemDirectory 得到，一般为 System32 目录，若为 32 位程序跑在 64 位系统下，则为 SysWOW64 目录。
3. Windows 目录中的 System 目录。
4. Windows 目录，该目录可以通过 GetWindowsDirectory 得到。
5. 进程的当前目录(通过SetCurrentDirectory设置的目录)。
6. PATH 环境变量中所列出的目录
如果调用 LoadLibrary 时传入的是绝对路径，那么加载程序将只尝试从该绝对路径搜索 DLL。

## 什么是装饰者模式
https://blog.csdn.net/lh844386434/article/details/17932039

## 快排
快速排序（QuickSort）是一种高效的排序算法，由托尼·霍尔（Tony Hoare）于1960年提出。其基本思想是分而治之（divide and conquer）。
### 快速排序的原理：
1. 选择基准值（Pivot）：
从待排序的数组中选择一个元素作为基准值，选择的方式可以多样（如选择第一个元素、最后一个元素、中间元素或随机元素）。
2. 分区（Partitioning）：
重新排列数组，使得基准值左侧的所有元素都不大于基准值，而基准值右侧的所有元素都不小于基准值。完成这一步后，基准值所在的位置就是它最后排序完成时的位置。
3. 递归排序：
递归地对基准值左右两边的子数组执行以上操作，直到子数组的大小减少到1（或0），此时数组完成排序。
### 时间复杂度：
- 最好情况：O(n log n)。
当每次分区都能将数组分为两个几乎相等的部分时，快速排序算法的性能最好。这样每层递归的复杂度是 O(n)，并且有 log n 层递归。
- 平均情况：O(n log n)。
即使分区不完全平衡，快速排序的平均性能也接近最好情况。平均情况下，快速排序是 O(n log n) 的时间复杂度。
- 最坏情况：O(n^2)。
当数组已经是正序或逆序排列，且每次选择的基准值是最小或最大元素时，快速排序的性能最差。在这种情况下，每次分区操作只能减少一个元素，导致了 n 层递归，每层递归的复杂度是 O(n)。
为了避免最坏情况，通常在实际的快速排序实现中，会采用随机选择基准值、三数中值或其他方法来尽量确保分区的平衡，或者在子数组较小时切换到其他排序算法如插入排序（这种混合排序方法称为"introsort"）。

## 手动调用虚函数
```cpp
#include <iostream>
#include <string>

class Base {
public:
    virtual void func1() { std::cout << "Base::func1()" << std::endl; }
    virtual void func2() { std::cout << "Base::func2()" << std::endl; }
};

typedef void(__thiscall* MyFunctionType)(Base* test);

int main() {
    Base b;
    void** vtable = *(void***)&b; // 将对象的地址转换为指向虚表的指针
    auto fptr = (MyFunctionType)(vtable[0]); // 取虚表中第一个函数的地址
    fptr(&b);
    return 0;
}
```

## 
